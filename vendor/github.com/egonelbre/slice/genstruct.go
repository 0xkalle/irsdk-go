// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// Small slice sorter generator.
package main

import (
	"flag"
	"os"
	"text/template"
)

const pkg = `// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Generated by running
//	genstruct -largest=256 > struct.go && go fmt struct.go
// DO NOT EDIT

package slice

import (
	"sort"
	"unsafe"
)

func swapStruct(size uintptr, less func(i, j int) bool, header unsafe.Pointer) (sort.Interface, bool) {
	switch size { {{range $size, $t := . }}
	case {{ $size }}:
		return &swap{{ $size }}{slice:*(*[]struct{{ $size }})(header), less:less}, true{{end}}
	default:
		return nil, false
	}
}

{{range $size, $t := . }}
// swap{{ $size }} swaps {{ $size }}-byte elements.
type struct{{ $size }} [{{$t.Count}}]uint{{$t.Prim}}
type swap{{ $size }} struct {
	slice []struct{{ $size }}
	less  func(i, j int) bool
}

func (s *swap{{ $size }}) Len() int           { return len(s.slice) }
func (s *swap{{ $size }}) Less(i, j int) bool { return s.less(i, j) }
func (s *swap{{ $size }}) Swap(i, j int)      {
	xs := s.slice
	a, b := &xs[i], &xs[j]
	{{ range $i, $n := $t.Swaps }} a[{{$i}}], b[{{$i}}] = b[{{$i}}], a[{{$i}}]; {{end}}
}

{{end}}
`

var largest = flag.Int("largest", 256, "specifies the largest size of specialized type")

type T struct {
	Count int
	Prim  int
	Swaps []struct{}
}

func main() {
	flag.Parse()

	counts := make(map[int]T)
	for i := 4; i <= *largest; i += 4 {
		if i%8 == 0 {
			counts[i] = T{i / 8, 64, make([]struct{}, i/8)}
		} else {
			counts[i] = T{i / 4, 32, make([]struct{}, i/4)}
		}
	}

	t := template.Must(template.New("").Parse(pkg))
	err := t.Execute(os.Stdout, counts)
	if err != nil {
		panic(err)
	}
}
